@page "/"
@using AutoPilot.App.Services
@using AutoPilot.App.Models
@using Markdig
@inject CopilotService CopilotService
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IDisposable

<div class="chat-container">
    @if (!CopilotService.IsInitialized)
    {
        <div class="initializing">
            <div class="spinner"></div>
            <p>Connecting to Copilot...</p>
            @if (!string.IsNullOrEmpty(initError))
            {
                <p class="error">@initError</p>
                <button @onclick="Initialize">Retry</button>
            }
        </div>
    }
    else if (activeSession == null)
    {
        <div class="no-session">
            <h2>Welcome to AutoPilot</h2>
            <p>Create a new session from the sidebar to start chatting with Copilot.</p>
        </div>
    }
    else
    {
        <div class="chat-header">
            <h2>@activeSession.Name</h2>
            <span class="model-badge">@activeSession.Model</span>
            @if (activeSession.SessionId != null)
            {
                <span class="session-id-badge" title="@activeSession.SessionId"><svg class="icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> @activeSession.SessionId[..8]</span>
            }
            @if (activeSession.IsProcessing)
            {
                <span class="typing-indicator">Copilot is typing...</span>
            }
        </div>

        <div class="messages" @ref="messagesContainer">
            @if (!activeSession.History.Any() && string.IsNullOrEmpty(streamingContent))
            {
                <div class="empty-chat">
                    <p>Start a conversation with Copilot!</p>
                </div>
            }
            else
            {
                @foreach (var msg in activeSession.History.ToList())
                {
                    @switch (msg.MessageType)
                    {
                        case ChatMessageType.User:
                            <div class="message user">
                                <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></div>
                                <div class="message-content">
                                    <div class="message-text">@((MarkupString)FormatUserMessage(msg.Content))</div>
                                    <div class="message-time">@msg.Timestamp.ToString("HH:mm")</div>
                                </div>
                            </div>
                            break;

                        case ChatMessageType.Assistant:
                            <div class="message assistant">
                                <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect x="2" y="8" width="20" height="8" rx="2"/><path d="M6 16v4"/><path d="M18 16v4"/><circle cx="9" cy="12" r="1" fill="currentColor"/><circle cx="15" cy="12" r="1" fill="currentColor"/></svg></div>
                                <div class="message-content">
                                    <div class="message-text markdown-body">@((MarkupString)RenderMarkdown(msg.Content))</div>
                                    <div class="message-time">@msg.Timestamp.ToString("HH:mm")</div>
                                </div>
                            </div>
                            break;

                        case ChatMessageType.Error:
                            <div class="error-card">
                                <span class="error-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></span>
                                <span class="error-text">@msg.Content</span>
                            </div>
                            break;

                        case ChatMessageType.System:
                            <div class="message system">
                                <div class="system-text">@msg.Content</div>
                            </div>
                            break;
                    }
                }

                @* Show current tool activity inline *@
                @if (!string.IsNullOrEmpty(currentToolName))
                {
                    <div class="tool-card running">
                        <div class="tool-header">
                            <span class="tool-info"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg> @FormatToolName(currentToolName)</span>
                            <span class="tool-status"><svg class="icon spin" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.22-8.56"/></svg> @currentTurnToolCount tool@(currentTurnToolCount != 1 ? "s" : "")</span>
                        </div>
                    </div>
                }

                @if (!string.IsNullOrEmpty(streamingContent))
                {
                    <div class="message assistant streaming">
                        <div class="message-avatar"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect x="2" y="8" width="20" height="8" rx="2"/><path d="M6 16v4"/><path d="M18 16v4"/><circle cx="9" cy="12" r="1" fill="currentColor"/><circle cx="15" cy="12" r="1" fill="currentColor"/></svg></div>
                        <div class="message-content">
                            <div class="message-text markdown-body">@((MarkupString)RenderMarkdown(streamingContent))</div>
                        </div>
                    </div>
                }
            }
        </div>

        @if (!string.IsNullOrEmpty(lastError))
        {
            <div class="error-bar">
                <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> @lastError</span>
                <button @onclick="() => lastError = null">×</button>
            </div>
        }

        <div class="input-area">
            @if (!string.IsNullOrEmpty(currentIntent))
            {
                <div class="intent-pill"><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg> @currentIntent</div>
            }
            @if (activeSession.MessageQueue.Any())
            {
                <div class="message-queue">
                    <div class="queue-header">
                        <span><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg> Queued (@activeSession.MessageQueue.Count)</span>
                        <button class="queue-clear-btn" @onclick="ClearQueue">Clear</button>
                    </div>
                    @for (var i = 0; i < activeSession.MessageQueue.Count; i++)
                    {
                        var index = i;
                        var msg = activeSession.MessageQueue[i];
                        <div class="queue-item">
                            <span class="queue-index">@(index + 1)</span>
                            <span class="queue-text">@Truncate(msg, 80)</span>
                            <button class="queue-remove-btn" @onclick="() => RemoveQueuedMessage(index)">×</button>
                        </div>
                    }
                </div>
            }
            <div class="input-row">
                <textarea @ref="textareaRef" @bind="userInput" @bind:event="oninput" 
                          @onkeydown="HandleKeyDown"
                          placeholder="@GetInputPlaceholder()"
                          rows="1"></textarea>
                @if (activeSession.IsProcessing)
                {
                    <button class="stop-btn" @onclick="StopResponse" title="Stop response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="1"/></svg>
                    </button>
                }
                <button @onclick="SendMessage" 
                        disabled="@(string.IsNullOrWhiteSpace(userInput))">
                    @if (activeSession.IsProcessing)
                    {
                        <text>Queue</text>
                    }
                    else
                    {
                        <text>Send</text>
                    }
                </button>
            </div>
            <div class="input-status-bar">
                <button class="plan-icon-toggle @(isPlanMode ? "active" : "")" @onclick="() => isPlanMode = !isPlanMode" title="Toggle planning mode — prefixes messages with [[PLAN]]">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="1.5" width="12" height="13" rx="1.5"/><line x1="5" y1="5" x2="5.01" y2="5"/><line x1="7.5" y1="5" x2="11" y2="5"/><line x1="5" y1="8" x2="5.01" y2="8"/><line x1="7.5" y1="8" x2="11" y2="8"/><line x1="5" y1="11" x2="5.01" y2="11"/><line x1="7.5" y1="11" x2="11" y2="11"/></svg>
                    <span>Planning</span>
                </button>
                <span class="status-sep">·</span>
                <span class="status-model">@(currentUsage?.Model ?? activeSession.Model)</span>
                @if (currentUsage != null)
                {
                    @if (currentUsage.InputTokens.HasValue || currentUsage.OutputTokens.HasValue)
                    {
                        <span class="status-sep">·</span>
                        <span class="status-tokens">↑@FormatTokenCount(currentUsage.InputTokens ?? 0) ↓@FormatTokenCount(currentUsage.OutputTokens ?? 0)</span>
                    }
                    @if (currentUsage.CurrentTokens.HasValue && currentUsage.TokenLimit.HasValue)
                    {
                        <span class="status-sep">·</span>
                        <span class="status-ctx" title="@currentUsage.CurrentTokens.Value / @currentUsage.TokenLimit.Value tokens">@FormatTokenCount(currentUsage.CurrentTokens.Value)/@FormatTokenCount(currentUsage.TokenLimit.Value) ctx</span>
                    }
                }
                <span class="status-sep">·</span>
                <span class="status-msgs">@activeSession.History.Count msgs</span>
            </div>
        </div>
    }
    
    @if (!string.IsNullOrEmpty(debugLog))
    {
        <div class="debug-panel">
            <div class="debug-header">Debug Log <button @onclick="() => debugLog = string.Empty">Clear</button></div>
            <pre>@debugLog</pre>
        </div>
    }
</div>

@code {
    private static readonly MarkdownPipeline MdPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    private AgentSessionInfo? activeSession;
    private string userInput = "";
    private bool isPlanMode = false;
    private string streamingContent = "";
    private string currentIntent = "";
    private SessionUsageInfo? currentUsage;
    private string? initError;
    private string? lastError;
    private string debugLog = "";
    private ElementReference messagesContainer;
    private ElementReference textareaRef;
    private bool _needsRedirect;
    private string? _redirectTo;
    private bool _needsScroll = true;

    protected override async Task OnInitializedAsync()
    {
        CopilotService.OnStateChanged += RefreshState;
        CopilotService.OnContentReceived += HandleContentReceived;
        CopilotService.OnSessionComplete += HandleSessionComplete;
        CopilotService.OnError += HandleError;
        CopilotService.OnDebug += HandleDebug;
        CopilotService.OnToolStarted += HandleToolStarted;
        CopilotService.OnToolCompleted += HandleToolCompleted;
        CopilotService.OnReasoningReceived += HandleReasoningReceived;
        CopilotService.OnReasoningComplete += HandleReasoningComplete;
        CopilotService.OnIntentChanged += HandleIntentChanged;
        CopilotService.OnUsageInfoChanged += HandleUsageInfoChanged;
        CopilotService.OnTurnStart += HandleTurnStart;
        CopilotService.OnTurnEnd += HandleTurnEnd;

        await Initialize();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsRedirect && _redirectTo != null)
        {
            _needsRedirect = false;
            Nav.NavigateTo(_redirectTo);
        }
        if (firstRender || _needsScroll)
        {
            _needsScroll = false;
            await ForceScrollToBottom();
        }
        try { await JS.InvokeVoidAsync("setupTextareaEnterHandler", textareaRef); } catch { }
    }

    private string currentToolName = "";
    private int currentTurnToolCount;

    private void HandleToolStarted(string sessionName, string toolName, string callId)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentToolName = toolName;
        currentTurnToolCount++;
        InvokeAsync(StateHasChanged);
    }

    private void HandleToolCompleted(string sessionName, string callId, string result, bool success)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        // Don't add to history — just clear current tool indicator
        currentToolName = "";
        InvokeAsync(StateHasChanged);
    }

    private void HandleReasoningReceived(string sessionName, string reasoningId, string content)
    {
        // Don't add reasoning to history — it clutters the view
        // The intent indicator already shows thinking state
    }

    private void HandleReasoningComplete(string sessionName, string reasoningId)
    {
        // No-op — reasoning not tracked in history
    }

    private void HandleIntentChanged(string sessionName, string intent)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = intent;
        InvokeAsync(StateHasChanged);
    }

    private void HandleUsageInfoChanged(string sessionName, SessionUsageInfo info)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        if (currentUsage == null)
        {
            currentUsage = info;
        }
        else
        {
            currentUsage = new SessionUsageInfo(
                info.Model ?? currentUsage.Model,
                info.CurrentTokens ?? currentUsage.CurrentTokens,
                info.TokenLimit ?? currentUsage.TokenLimit,
                info.InputTokens ?? currentUsage.InputTokens,
                info.OutputTokens ?? currentUsage.OutputTokens);
        }
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnStart(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName || activeSession == null) return;
        // Don't clear streamingContent — let it accumulate across turns
        // so messages don't vanish between tool-call-driven turns.
        // CompleteResponse will add the full response to History and 
        // SendPromptAsync clears streamingContent when done.
        currentTurnToolCount = 0;
        currentToolName = "";
        InvokeAsync(StateHasChanged);
    }

    private void HandleTurnEnd(string sessionName)
    {
        if (sessionName != CopilotService.ActiveSessionName) return;
        currentIntent = "";
        currentToolName = "";
        currentTurnToolCount = 0;
        // Don't clear streamingContent here — CompleteResponse hasn't added it to History yet.
        // It gets cleared in HandleTurnStart when the next turn begins.
        InvokeAsync(StateHasChanged);
    }

    private void HandleDebug(string message)
    {
        debugLog = $"{DateTime.Now:HH:mm:ss} {message}\n{debugLog}";
        if (debugLog.Length > 2000) debugLog = debugLog[..2000];
        InvokeAsync(StateHasChanged);
    }

    private async Task Initialize()
    {
        initError = null;
        try
        {
            await CopilotService.InitializeAsync();
            // RestorePreviousSessionsAsync is already called inside InitializeAsync
            var uiState = CopilotService.LoadUiState();
            if (uiState != null)
            {
                if (!string.IsNullOrEmpty(uiState.ActiveSession))
                    CopilotService.SetActiveSession(uiState.ActiveSession);
                if (uiState.CurrentPage is "/dashboard" or "/settings")
                {
                    _needsRedirect = true;
                    _redirectTo = uiState.CurrentPage;
                }
            }
        }
        catch (Exception ex)
        {
            initError = $"Failed to connect: {ex.Message}";
        }
        RefreshState();
    }

    private void HandleError(string sessionName, string error)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            lastError = error;
            InvokeAsync(StateHasChanged);
        }
    }

    private void RefreshState()
    {
        var prev = activeSession?.Name;
        activeSession = CopilotService.GetActiveSession();
        if (activeSession?.Name != prev)
        {
            _needsScroll = true;
            // Clean up any stale tool/reasoning entries from history
            activeSession?.History.RemoveAll(m =>
                m.MessageType is ChatMessageType.ToolCall or ChatMessageType.Reasoning);
        }
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private void HandleContentReceived(string sessionName, string content)
    {
        if (sessionName == CopilotService.ActiveSessionName && activeSession?.IsProcessing == true)
        {
            streamingContent += content;
            InvokeAsync(async () =>
            {
                StateHasChanged();
                await ScrollToBottom();
            });
        }
    }

    private void HandleSessionComplete(string sessionName, string summary)
    {
        if (sessionName == CopilotService.ActiveSessionName)
        {
            currentIntent = "";
        }
        InvokeAsync(async () =>
        {
            try { await JS.InvokeVoidAsync("showNotification", sessionName, summary); }
            catch { }
        });
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task StopResponse()
    {
        if (activeSession == null) return;
        await CopilotService.AbortSessionAsync(activeSession.Name);
        streamingContent = "";
        StateHasChanged();
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || activeSession == null)
            return;

        var prompt = userInput.Trim();
        if (isPlanMode)
            prompt = $"[[PLAN]] {prompt}";
        userInput = "";

        if (activeSession.IsProcessing)
        {
            CopilotService.EnqueueMessage(activeSession.Name, prompt);
            return;
        }

        streamingContent = "";
        currentIntent = "";
        lastError = null;

        try
        {
            await CopilotService.SendPromptAsync(activeSession.Name, prompt);
            streamingContent = "";
        }
        catch (Exception ex)
        {
            lastError = $"Error: {ex.Message}";
        }
        await ForceScrollToBottom();
    }

    private void RemoveQueuedMessage(int index)
    {
        if (activeSession != null) CopilotService.RemoveQueuedMessage(activeSession.Name, index);
    }

    private void ClearQueue()
    {
        if (activeSession != null) CopilotService.ClearQueue(activeSession.Name);
    }

    private string GetInputPlaceholder()
    {
        if (isPlanMode) return "Plan mode: describe what you want planned...";
        if (activeSession?.IsProcessing == true) return "Type to queue next message... (sent when idle)";
        return "Type a message... (Enter to send, Shift+Enter for new line)";
    }

    private string Truncate(string text, int maxLen)
    {
        text = text.Replace("\n", " ").Replace("\r", "");
        return text.Length > maxLen ? text[..maxLen] + "…" : text;
    }

    private static string RenderMarkdown(string content)
    {
        if (string.IsNullOrEmpty(content)) return "";
        try { return Markdig.Markdown.ToHtml(content, MdPipeline); }
        catch { return System.Net.WebUtility.HtmlEncode(content).Replace("\n", "<br/>"); }
    }

    private static string FormatUserMessage(string content)
    {
        var escaped = System.Net.WebUtility.HtmlEncode(content);
        return escaped.Replace("\n", "<br/>");
    }

    private static int LineCount(string? text)
    {
        if (string.IsNullOrEmpty(text)) return 0;
        var count = 1;
        foreach (var c in text) { if (c == '\n') count++; }
        return count;
    }

    private static string FirstLines(string? text, int lines)
    {
        if (string.IsNullOrEmpty(text)) return "";
        var idx = 0;
        for (var i = 0; i < lines && idx < text.Length; i++)
        {
            var next = text.IndexOf('\n', idx);
            if (next < 0) break;
            idx = next + 1;
        }
        if (idx <= 0 || idx >= text.Length) return text;
        return text[..idx] + "…";
    }

    private static string FormatToolName(string toolName)
    {
        if (string.IsNullOrEmpty(toolName)) return "";
        return string.Join(" ", toolName.Split('_').Select(w =>
            w.Length > 0 ? char.ToUpperInvariant(w[0]) + w[1..].ToLowerInvariant() : w));
    }

    private static string TruncateResult(string result, int maxLength = 1500)
    {
        if (string.IsNullOrEmpty(result) || result.Length <= maxLength) return result ?? "";
        return result[..maxLength] + "\n… (truncated)";
    }

    private static bool IsUnusableResult(string? content)
    {
        if (string.IsNullOrEmpty(content)) return true;
        if (content.StartsWith("GitHub.Copilot.SDK.")) return true;
        if (content is "(no result)" or "Intent logged") return true;
        return false;
    }

    private static string FormatTokenCount(int count) =>
        count >= 1000 ? $"{count / 1000}k" : count.ToString();

    private async Task ScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("smartScrollToBottom", messagesContainer); }
        catch { }
    }

    private async Task ForceScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("scrollToBottom", messagesContainer); }
        catch { }
    }

    public void Dispose()
    {
        CopilotService.OnStateChanged -= RefreshState;
        CopilotService.OnContentReceived -= HandleContentReceived;
        CopilotService.OnSessionComplete -= HandleSessionComplete;
        CopilotService.OnError -= HandleError;
        CopilotService.OnDebug -= HandleDebug;
        CopilotService.OnToolStarted -= HandleToolStarted;
        CopilotService.OnToolCompleted -= HandleToolCompleted;
        CopilotService.OnReasoningReceived -= HandleReasoningReceived;
        CopilotService.OnReasoningComplete -= HandleReasoningComplete;
        CopilotService.OnIntentChanged -= HandleIntentChanged;
        CopilotService.OnUsageInfoChanged -= HandleUsageInfoChanged;
        CopilotService.OnTurnStart -= HandleTurnStart;
        CopilotService.OnTurnEnd -= HandleTurnEnd;
    }
}
